def _replace_sentinels(lf: pl.LazyFrame, exclude_int: set = None) -> pl.LazyFrame:
    """Replace INT_NULL/FLOAT_NULL sentinels back to real nulls."""
    if exclude_int is None:
        exclude_int = set()
    schema = lf.collect_schema()
    int_exprs = [
        pl.when(pl.col(c) == INT_NULL).then(None).otherwise(pl.col(c)).alias(c)
        for c, dt in schema.items()
        if dt in (pl.Int32, pl.Int64) and c not in exclude_int
    ]
    float_exprs = [
        pl.when(pl.col(c) == FLOAT_NULL).then(None).otherwise(pl.col(c)).alias(c)
        for c, dt in schema.items()
        if dt in (pl.Float32, pl.Float64)
    ]
    if int_exprs or float_exprs:
        lf = lf.with_columns(int_exprs + float_exprs)
    return lf


def colleague_calculate_lookthrough(
    pos: pl.LazyFrame,
    lt: Optional[pl.LazyFrame],
    config: str,
    pid: int,
    granularity: str,  # "no", "essential_lookthroughs", "complete_lookthroughs"
) -> pl.LazyFrame:
    """Colleague's approach with minimal fixes to make it work.

    Fixes applied to original code:
    1. by_name: only list columns that exist in the schema
    2. LT join: use parent_instrument_id instead of composite_id
    3. is_composite: use instrument_id_right instead of composite_id
    4. Sentinel replacement: revert INT_NULL/FLOAT_NULL to real nulls
    """
    suffix = f"{config}_{pid}"
    fcol = f"f_{suffix}"

    # --- Fix: Replace sentinel nulls ---
    pos = _replace_sentinels(pos, exclude_int={"instrument_id", "identifier"})

    # --- Filter by perspective ---
    pos = pos.filter(pl.col(fcol).is_not_null())

    # --- Filter null-weight positions ---
    pos = pos.filter(
        ~(
            ((pl.col("container").cast(pl.Utf8) == "holding")
             & pl.col(f"initial_weight_{suffix}").is_null()
             & pl.col(f"resulting_weight_{suffix}").is_null())
            | ((pl.col("container").cast(pl.Utf8) == "selected_reference")
               & pl.col(f"weight_{suffix}").is_null())
            | ((pl.col("container").cast(pl.Utf8) == "contractual_reference")
               & pl.col(f"weight_{suffix}").is_null())
        )
    )

    # --- Original selector logic (fixed: only columns that exist) ---
    pos_schema = pos.collect_schema().names()

    container = pl.selectors.by_name('container')

    # Fix: only include columns that actually exist in positions
    _id_candidates = ['container', 'record_type', 'parent_instrument_id',
                      'instrument_id', 'composite_id', 'identifier']
    identifiers = pl.selectors.by_name([c for c in _id_candidates if c in pos_schema])

    weights_columns = pl.selectors.matches(
        r'^(initial_weight|resulting_weight|initial_exposure_weight'
        r'|resulting_exposure_weight|weight|resulting_exposure|initial_exposure)$'
    )

    psp_weights = pl.selectors.matches(
        r'^(initial_weight|resulting_weight|initial_exposure_weight'
        r'|resulting_exposure_weight|weight)_\d+_-?\d+(_right)?$'
    )

    psp_factors = pl.selectors.matches(
        r'^(f_\d+_-?\d+|parent_f_\d+_-?\d+|f_\d+_-?\d+_factors)$'
    )
    psp_cols = psp_weights | psp_factors
    meta_data = ~(identifiers | weights_columns | psp_cols)

    meta_data_cols = pos.select(meta_data).collect_schema().names()

    # Fix: use instrument_id_right from the join instead of composite_id
    is_holding = pl.col('container').cast(pl.Utf8).eq('holding')
    is_contractual = pl.col('container').cast(pl.Utf8).eq('contractual_reference')
    is_selected = pl.col('container').cast(pl.Utf8).eq('selected_reference')

    # --- Composite join ---
    is_no = (granularity == "no")
    if is_no or lt is None:
        joined = pos.with_columns([
            pl.lit(None, dtype=pl.Int64).alias("instrument_id_right"),
        ])
    else:
        lt_filtered = lt.filter(
            pl.col(fcol).is_not_null()
            & pl.col("record_type").cast(pl.Utf8).eq(granularity)
        )
        lt_filtered = _replace_sentinels(
            lt_filtered,
            exclude_int={"instrument_id", "parent_instrument_id", "identifier"},
        )

        # Fix: use parent_instrument_id instead of composite_id
        joined = pos.join(
            lt_filtered,
            left_on=['instrument_id', 'container'],
            right_on=['parent_instrument_id', 'container'],
            coalesce=False,
            how='left',
        )

    # Fix: detect composite via instrument_id_right instead of composite_id
    is_composite = pl.col('instrument_id_right').is_not_null()

    joined = joined.select(
        'container',
        pl.col('instrument_id').alias('parent_instrument_id'),
        pl.when(is_composite)
        .then('instrument_id_right')
        .otherwise('instrument_id')
        .alias('instrument_id'),
        *[
            pl.when(is_composite).then(f'{c}_right').otherwise(pl.col(c)).alias(c)
            if f'{c}_right' in joined.collect_schema().names()
            else pl.col(c)
            for c in meta_data_cols
        ],
        psp_factors,
        psp_weights,
    )

    # --- Per perspective ---
    value_cols = pl.selectors.matches(
        rf'^(initial_weight|resulting_weight|initial_exposure_weight'
        rf'|resulting_exposure_weight|weight)_{config}_{pid}'
    )

    initial_exposure_weight = pl.col(f'initial_exposure_weight_{suffix}')
    resulting_exposure_weight = pl.col(f'resulting_exposure_weight_{suffix}')
    weight = pl.col(f'weight_{suffix}')
    composite_weight = pl.col(f'weight_{suffix}_right')
    has_composite_weight = composite_weight.is_not_null()

    df = joined.filter(pl.col(fcol).is_not_null())

    if is_no:
        iw = pl.col(f'initial_weight_{suffix}')
        rw = pl.col(f'resulting_weight_{suffix}')
        df = df.group_by(~(container | value_cols | psp_factors)).agg(
            iw.filter(is_holding).sum().alias('PI'),
            rw.filter(is_holding).sum().alias('PR'),
            weight.filter(is_contractual).sum().alias('BC'),
            weight.filter(is_selected).sum().alias('BS'),
        )
    else:
        df = df.group_by(~(container | value_cols | psp_factors)).agg(
            pl.when(has_composite_weight)
            .then(initial_exposure_weight * composite_weight)
            .otherwise(initial_exposure_weight)
            .filter(is_holding)
            .sum()
            .alias('PI'),
            pl.when(has_composite_weight)
            .then(resulting_exposure_weight * composite_weight)
            .otherwise(resulting_exposure_weight)
            .filter(is_holding)
            .sum()
            .alias('PR'),
            weight.filter(is_contractual).sum().alias('BC'),
            weight.filter(is_selected).sum().alias('BS'),
        )

    # --- Fill nulls, filter small, active weights ---
    df = df.with_columns([
        pl.col(c).fill_null(0.0).fill_nan(0.0).alias(c)
        for c in ['PI', 'PR', 'BS', 'BC']
    ])
    df = df.with_columns([
        pl.when(pl.col(c).abs().le(1e-15)).then(0.0).otherwise(pl.col(c)).alias(c)
        for c in ['PI', 'PR', 'BS', 'BC']
    ])
    df = df.with_columns([
        (pl.col('PI') - pl.col('BC')).alias('AIC'),
        (pl.col('PR') - pl.col('BC')).alias('ARC'),
        (pl.col('PI') - pl.col('BS')).alias('AIS'),
        (pl.col('PR') - pl.col('BS')).alias('ARS'),
    ])

    return df




def build_perspective_dict_colleague(
    positions_lf: pl.LazyFrame,
    lookthroughs_lf: Optional[pl.LazyFrame],
    perspective_configs: Dict[str, Dict[str, List[str]]],
    record_types: List[str] = None,
) -> Dict[str, Dict[int, Dict[str, pl.LazyFrame]]]:
    """Build dict structure using colleague's approach: {config: {pid: {granularity: LazyFrame}}}"""
    if record_types is None:
        record_types = ["essential_lookthroughs", "complete_lookthroughs"]

    result: Dict[str, Dict[int, Dict[str, pl.LazyFrame]]] = {}

    for config, pmap in perspective_configs.items():
        result[config] = {}
        for pid_str in pmap:
            pid = int(pid_str)
            result[config][pid] = {}

            result[config][pid]["no"] = colleague_calculate_lookthrough(
                pos=positions_lf,
                lt=lookthroughs_lf,
                config=config,
                pid=pid,
                granularity="no",
            )

            for rt in record_types:
                result[config][pid][rt] = colleague_calculate_lookthrough(
                    pos=positions_lf,
                    lt=lookthroughs_lf,
                    config=config,
                    pid=pid,
                    granularity=rt,
                )

    return result